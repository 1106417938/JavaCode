[toc]

# 进制

>| 二级制   | 0b10001 |
>| -------- | ------- |
>| 八进制   | 030     |
>| 十进制   | 10      |
>| 十六进制 | 0x13    |
>
>>十进制转其他进制，获取余数，然后倒序即可
>>
>>其他进制转10进制：按位次乘以进制的位次幂，相加即可
>>
>>二进制转八进制：从最低位开始，每三位一组，每一组产生一个8进制数字，最高位不足三位，补0补齐三位，将转化出来的数字依次排列
>>
>>二进制转16进制：从最低位开始，每四位一组，每一组产生一个16进制数字，最高位不足四位，补0补齐四位，将转化出来的数字依次排列

# 数据类型转换

>隐式转换/自动类型转换
>
>>| 规律一：：小的类型可以自动转化为大类型 | byte-short->int->long                |
>>| -------------------------------------- | ------------------------------------ |
>>| 规律二：整数可以转化为小数             | byte-short->int->long->float->double |
>>| 规律三：字符可以转化为整数             | char->int                            |
>
>显示转换
>
>>| 规律一：大的类型转换为小的类型       | byte->Int  |
>>| ------------------------------------ | ---------- |
>>| 规律二：小数转化为整数时，精度会损失 | float->int |
>>| 规则三：将整数转换为字符             | Int->char  |
>
>

# 数字的原码，补码，反码

>正数的原码、补码、反码都是自己
>
>负数
>
>>~~~
>>-10
>>10000000 00000000 0000000 00001010 原码
>>11111111 11111111 1111111 11110101 补码
>>11111111 11111111 1111111 11110110 反码
>>~~~

# java内存结构

>java所占用的内存分为5块:栈内存、堆内存、方法区、本地方法栈、PC寄存器
>
>>栈内存：
>>
>>栈内存本身是用于存储变量的。变量一旦使用完成，会立即从栈内存中移除
>
>>堆内存
>>
>>堆内存存储的是对象（数组本身也是一种对象）。存储在堆内存中的元素自动赋予初始值 
>>
>>byte/short/int/:0
>>
>>float:0.0f
>>
>>double:0.0
>>
>>char:'\u0000'
>>
>>boolean:false
>
>其他初始值都是null
>
>当这个对象使用完成之后，不会立即移除出堆内存，而是在不定的某个时刻被垃圾回收器回收释放空间
>
>例子：
>
>~~~java
>int[] arr = new int[3]
>~~~
>
>![](D:\JavaCode\java内存结构1.png)
>
>~~~java
>int[] arr = new int[3]
>int[] arr2 = arr
>arr2[0] = 5
>~~~
>
>![](D:\JavaCode\java内存结构2.png)
>
>数组赋值是传的是地址
>
>如果是重新new一个新的数组
>
>~~~java
>int[] arr = new int[3]
>arr = new int[3]
>arr[0] = 7
>~~~
>
>![](D:\JavaCode\java内存结构3.png)
>
>

# 数组

>将数组中的元素取出来变为字符串
>
>~~~java
>Arrays.toString(数组名)
>~~~
>
>元素的排序
>
>~~~java
>Arrays.sort()//底层是基于快速排序和归并排序
>~~~

# 重载

>在同一个类中，出现方法名相同而参数列表不同的方法

# 传值和传地址

>~~~java
>int a = 1
>changeI(a)
>private static void changeI(int a){
>    a++
>}
>~~~
>
>传入的是基本数据类型，只会在栈内存里面a加了1，使用完后，会被回收，函数体外a值还是1
>
>![](D:\JavaCode\java内存结构4.png)
>
>~~~java
>int[] a = new int[3];
>a[0] = 1;
>changeI(a)
>private static void changeI(int[] arr){
>    a[0]++;
>}
>~~~
>
>![](D:\JavaCode\java内存结构5.png)
>
>~~~java
>int[] a = new int[3];
>int[] a2 = new intp[3];
>swap(a, a2)
>private static void swap(int[] arr1, int[] arr2){
>    int[] temp = arr1;
>    arr1 = arr2;
>    arr2 = temp;
>}
>~~~
>
>![](D:\JavaCode\java内存结构6.png)
>
>栈内存确实地址交换了，但是出了sawp函数后，函数空间被回收，不影响main函数里面的地址

# 面向对象

>成员变量：定在类中的变量
>
>局部变量：定义在方法中的变量
>
>>区别
>>
>>|          | 成员变量                                       | 局部变量                                                     |
>>| -------- | ---------------------------------------------- | ------------------------------------------------------------ |
>>| 定义位置 | 定义在类中                                     | 定义在方法/代码块中                                          |
>>| 存储位置 | 存储在堆内存中，并且在堆内存中会自动赋予默认值 | 存储在栈内存中                                               |
>>| 生命周期 | 在对象创建的时候产生，在对象被回收的释放       | 在方法执行的时候产生，方法执行完成之后，局部变量就随着方法一起移除出栈内存 |
>
>this关键字
>
>> 用在类里面，代表当前在活动的对象，通过this在本类中调用本类的属性或者是方法
>>
>> 在类外，通过对象来调用方法或者是属性；那么在类内就以this代替
>
>代码块
>
>初始代码块/构造函数代码块
>
>>在类中用{}括起来的代码，无论调用哪个构造方法，该代码块都会先于构造方法执行一次
>
>局部代码块
>
>>在方法中，用一对{}括起来的代码
>
>权限修饰符
>
>用于限制属性或者方法的使用范围的修饰符
>
>>|           | 本类中 | 子类中 | 同包类中 | 其他类中 |
>>| --------- | ------ | ------ | -------- | -------- |
>>| public    | 可以   | 可以   | 可以     | 可以     |
>>| protected | 可以   | 可以   | 可以     | 不可以   |
>>| 默认      | 可以   | 可以   | 可以     | 不可以   |
>>| private   | 可以   | 不可以 | 不可以   | 不可以   |
>
>继承
>
>>如果一些类中有一些公有的行为和特征，那么这个时候可以将这些类中的公有的行为和特征提取到一个新的类中，然后利用extends关键字让原来的类和新的类产生联系，这种关系称之为继承
>>
>>子类通过继承可以使用父类中的**部分**的方法和属性
>>
>>注意：**子类通过继承，可以继承父类全部的方法和属性，但是只有部分方法和属性对子类是可见的，所以子类也只能使用这一部分可见的方法和属性**
>>
>>在Java中，支持的是类和类之间的单继承 - 一个子类只能有一个父类，但是一个父类可以有多个子类
>>
>>>super关键字
>>>
>>>>在子类中调用父类中的方法或者属性，可以认为是父类的虚拟对象
>>
>>
>
>

