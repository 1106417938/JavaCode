[toc]

# 进制

>| 二级制   | 0b10001 |
>| -------- | ------- |
>| 八进制   | 030     |
>| 十进制   | 10      |
>| 十六进制 | 0x13    |
>
>>十进制转其他进制，获取余数，然后倒序即可
>>
>>其他进制转10进制：按位次乘以进制的位次幂，相加即可
>>
>>二进制转八进制：从最低位开始，每三位一组，每一组产生一个8进制数字，最高位不足三位，补0补齐三位，将转化出来的数字依次排列
>>
>>二进制转16进制：从最低位开始，每四位一组，每一组产生一个16进制数字，最高位不足四位，补0补齐四位，将转化出来的数字依次排列

# 数据类型转换

>隐式转换/自动类型转换
>
>>| 规律一：：小的类型可以自动转化为大类型 | byte-short->int->long                |
>>| -------------------------------------- | ------------------------------------ |
>>| 规律二：整数可以转化为小数             | byte-short->int->long->float->double |
>>| 规律三：字符可以转化为整数             | char->int                            |
>
>显示转换
>
>>| 规律一：大的类型转换为小的类型       | byte->Int  |
>>| ------------------------------------ | ---------- |
>>| 规律二：小数转化为整数时，精度会损失 | float->int |
>>| 规则三：将整数转换为字符             | Int->char  |
>
>

# 数字的原码，补码，反码

>正数的原码、补码、反码都是自己
>
>负数
>
>>~~~
>>-10
>>10000000 00000000 0000000 00001010 原码
>>11111111 11111111 1111111 11110101 补码
>>11111111 11111111 1111111 11110110 反码
>>~~~

# java内存结构

>java所占用的内存分为5块:栈内存、堆内存、方法区、本地方法栈、PC寄存器
>
>>栈内存：
>>
>>栈内存本身是用于存储变量的。变量一旦使用完成，会立即从栈内存中移除
>
>>堆内存
>>
>>堆内存存储的是对象（数组本身也是一种对象）。存储在堆内存中的元素自动赋予初始值 
>>
>>byte/short/int/:0
>>
>>float:0.0f
>>
>>double:0.0
>>
>>char:'\u0000'
>>
>>boolean:false
>
>其他初始值都是null
>
>当这个对象使用完成之后，不会立即移除出堆内存，而是在不定的某个时刻被垃圾回收器回收释放空间
>
>例子：
>
>~~~java
>int[] arr = new int[3]
>~~~
>
>![](D:\JavaCode\java内存结构1.png)
>
>~~~java
>int[] arr = new int[3]
>int[] arr2 = arr
>arr2[0] = 5
>~~~
>
>![](D:\JavaCode\java内存结构2.png)
>
>数组赋值是传的是地址
>
>如果是重新new一个新的数组
>
>~~~java
>int[] arr = new int[3]
>arr = new int[3]
>arr[0] = 7
>~~~
>
>![](D:\JavaCode\java内存结构3.png)
>
>

# 数组

>将数组中的元素取出来变为字符串
>
>~~~java
>Arrays.toString(数组名)
>~~~
>
>元素的排序
>
>~~~java
>Arrays.sort()//底层是基于快速排序和归并排序
>~~~

# 重载

>在同一个类中，出现方法名相同而参数列表不同的方法

# 传值和传地址

>~~~java
>int a = 1
>changeI(a)
>private static void changeI(int a){
>    a++
>}
>~~~
>
>传入的是基本数据类型，只会在栈内存里面a加了1，使用完后，会被回收，函数体外a值还是1
>
>![](D:\JavaCode\java内存结构4.png)
>
>~~~java
>int[] a = new int[3];
>a[0] = 1;
>changeI(a)
>private static void changeI(int[] arr){
>    a[0]++;
>}
>~~~
>
>![](D:\JavaCode\java内存结构5.png)
>
>~~~java
>int[] a = new int[3];
>int[] a2 = new intp[3];
>swap(a, a2)
>private static void swap(int[] arr1, int[] arr2){
>    int[] temp = arr1;
>    arr1 = arr2;
>    arr2 = temp;
>}
>~~~
>
>![](D:\JavaCode\java内存结构6.png)
>
>栈内存确实地址交换了，但是出了sawp函数后，函数空间被回收，不影响main函数里面的地址

# 面向对象

>>成员变量：定在类中的变量
>>
>>局部变量：定义在方法中的变量
>>
>>
>
>

